<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FAQ Technique - FHIRHub</title>
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="/css/sidebar-menu.css">
    <link rel="stylesheet" href="/css/dev-faq.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body class="with-sidebar">
    <!-- Le menu latéral sera injecté ici -->
    <div id="sidebarContainer"></div>

    <div class="main-content with-sidebar">
        <header class="faq-header">
            <h1>Documentation Technique</h1>
            <p class="subtitle">Réponses aux questions techniques pour les développeurs et mainteneurs</p>
            <div class="search-container">
                <input type="text" id="faqSearch" placeholder="Rechercher une question..." aria-label="Rechercher dans la FAQ">
                <button type="button" id="searchButton"><i class="fas fa-search"></i></button>
            </div>
        </header>

        <nav class="category-nav">
            <ul id="categoryList">
                <!-- Les catégories seront générées dynamiquement par JavaScript -->
            </ul>
        </nav>

        <div class="toc-container">
            <div class="toc-header">
                <h2>Table des matières</h2>
                <button type="button" id="tocToggle" aria-label="Afficher/masquer la table des matières">
                    <i class="fas fa-chevron-down"></i>
                </button>
            </div>
            <ul id="tocList" class="visible">
                <!-- La table des matières sera générée dynamiquement par JavaScript -->
            </ul>
        </div>

        <div class="faq-container">
            <!-- Section Système de terminologie -->
            <section id="terminology" class="faq-section">
                <h2>Système de terminologie</h2>
                
                <div class="faq-item">
                    <h3 id="terminology-corrupt">Comment le système gère-t-il les fichiers de terminologie non valides ou corrompus ?</h3>
                    <div class="faq-answer">
                        <p>Le système FHIRHub implémente une stratégie robuste en 3 étapes pour gérer les fichiers de terminologie non valides ou corrompus :</p>
                        
                        <ol>
                            <li><strong>Validation préventive :</strong> Lors du chargement d'un fichier de terminologie, le système effectue une validation complète (syntaxe JSON, structure attendue, présence des champs obligatoires).</li>
                            <li><strong>Sauvegarde automatique :</strong> Avant toute mise à jour ou modification, le système crée une sauvegarde automatique avec le préfixe "backup_" + nom du fichier original.</li>
                            <li><strong>Mécanisme de restauration :</strong> Si un fichier est détecté comme corrompu lors de la lecture, le système tente automatiquement de restaurer la dernière version valide depuis les fichiers de sauvegarde.</li>
                        </ol>
                        
                        <p>Voici le code principal qui gère la détection et la restauration (dans <code>routes/terminology.js</code>) :</p>
                        
                        <pre><code>// Essayer de lire le fichier
try {
  const data = await readTerminologyFile(filename);
  return data;
} catch (error) {
  console.error(`Erreur lors de la lecture du fichier ${filename}:`, error);
  
  // Tenter une restauration automatique depuis la sauvegarde
  try {
    const backupFilename = `backup_${filename}`;
    console.log(`Tentative de restauration depuis ${backupFilename}...`);
    const backupData = await readTerminologyFile(backupFilename);
    
    // Copier la sauvegarde vers le fichier original
    await fs.promises.writeFile(
      path.join(terminologyDir, filename),
      JSON.stringify(backupData, null, 2)
    );
    
    console.log(`Restauration réussie depuis ${backupFilename}`);
    return backupData;
  } catch (backupError) {
    console.error('Échec de la restauration:', backupError);
    throw new Error(`Impossible de lire ou restaurer le fichier ${filename}`);
  }
}</code></pre>
                    </div>
                </div>
                
                <div class="faq-item">
                    <h3 id="terminology-backup">Quel est le mécanisme exact de sauvegarde des fichiers de terminologie et quand est-il déclenché ?</h3>
                    <div class="faq-answer">
                        <p>Le mécanisme de sauvegarde des fichiers de terminologie est automatique et se déclenche dans deux cas précis :</p>
                        
                        <ol>
                            <li><strong>Lors de chaque lecture réussie :</strong> Si un fichier est lu correctement, une sauvegarde est créée ou mise à jour.</li>
                            <li><strong>Avant chaque mise à jour :</strong> Avant d'écrire dans un fichier, le système sauvegarde d'abord l'ancienne version.</li>
                        </ol>
                        
                        <p>Les fichiers de sauvegarde sont stockés dans le même répertoire que les fichiers originaux avec le préfixe "backup_". Ce mécanisme garantit qu'il existe toujours une version fonctionnelle récente en cas de corruption.</p>
                        
                        <p>Implémentation dans <code>src/services/terminologyService.js</code> :</p>
                        
                        <pre><code>async function createBackup(filename) {
  const filePath = path.join(terminologyDir, filename);
  const backupPath = path.join(terminologyDir, `backup_${filename}`);
  
  try {
    // Vérifier si le fichier original existe
    if (await fileExists(filePath)) {
      // Copier le fichier vers la sauvegarde
      await fs.promises.copyFile(filePath, backupPath);
      console.log(`Sauvegarde créée: ${backupPath}`);
      return true;
    }
    return false;
  } catch (error) {
    console.error(`Erreur lors de la création de la sauvegarde pour ${filename}:`, error);
    return false;
  }
}</code></pre>
                    </div>
                </div>
                
                <div class="faq-item">
                    <h3 id="terminology-cache">Comment sont chargés et mis en cache les fichiers de terminologie pour optimiser les performances ?</h3>
                    <div class="faq-answer">
                        <p>FHIRHub utilise un système de mise en cache à deux niveaux pour optimiser l'accès aux fichiers de terminologie :</p>
                        
                        <ol>
                            <li><strong>Cache mémoire :</strong> Les fichiers de terminologie fréquemment utilisés sont stockés en mémoire à l'aide d'une Map JavaScript avec une durée de validité configurable.</li>
                            <li><strong>Cache de pré-calcul :</strong> Pour certaines opérations complexes comme les recherches inversées (code vers description), des index sont pré-calculés et mis en cache.</li>
                        </ol>
                        
                        <p>Le système utilise aussi un mécanisme de rechargement conditionnel basé sur les dates de modification des fichiers.</p>
                        
                        <p>Implémentation du système de cache :</p>
                        
                        <pre><code>// Structure de cache global
const terminologyCache = {
  files: new Map(),  // Stocke les contenus des fichiers
  indexes: new Map(), // Stocke les index pré-calculés
  lastCheck: 0        // Timestamp de la dernière vérification
};

async function getTerminologyFile(filename, forceReload = false) {
  const now = Date.now();
  const cacheEntry = terminologyCache.files.get(filename);
  
  // Vérifier si une entrée de cache valide existe
  if (!forceReload && cacheEntry && (now - cacheEntry.timestamp < CACHE_TTL_MS)) {
    console.log(`Utilisation du cache pour ${filename}`);
    return cacheEntry.data;
  }
  
  // Sinon, charger depuis le disque
  try {
    const filePath = path.join(terminologyDir, filename);
    const fileData = await fs.promises.readFile(filePath, 'utf8');
    const parsedData = JSON.parse(fileData);
    
    // Mettre à jour le cache
    terminologyCache.files.set(filename, {
      data: parsedData,
      timestamp: now
    });
    
    // Créer une sauvegarde après chaque lecture réussie
    await createBackup(filename);
    
    return parsedData;
  } catch (error) {
    console.error(`Erreur de chargement pour ${filename}:`, error);
    throw error;
  }
}</code></pre>
                    </div>
                </div>
                
                <div class="faq-item">
                    <h3 id="terminology-oids">Comment les identifiants OID français sont-ils résolus lors de la conversion HL7 vers FHIR ?</h3>
                    <div class="faq-answer">
                        <p>La résolution des identifiants OID français est une fonctionnalité clé de FHIRHub, particulièrement importante pour la conformité avec les spécifications ANS (Agence du Numérique en Santé).</p>
                        
                        <p>Lorsqu'un message HL7 contient un OID français, le processus suivant s'exécute :</p>
                        
                        <ol>
                            <li>Le système recherche d'abord l'OID dans le fichier <code>french_terminology/ans_oids.json</code> qui contient les mappings officiels ANS.</li>
                            <li>Si l'OID est trouvé, le système récupère son URL FHIR correspondante (généralement un système de terminologie).</li>
                            <li>Cette URL est ensuite utilisée comme système de référence pour les ressources FHIR générées.</li>
                            <li>En cas d'absence dans le fichier principal, le système tente une résolution alternative via d'autres sources comme <code>ans_terminology_systems.json</code>.</li>
                        </ol>
                        
                        <p>Exemple de résolution d'OID dans le convertisseur :</p>
                        
                        <pre><code>// Résoudre un OID français vers une URL de système FHIR
function resolveOID(oid) {
  // Chercher dans la table de mapping OID
  if (oidMappings[oid]) {
    logger.debug(`OID résolu: ${oid} -> ${oidMappings[oid].url}`);
    return oidMappings[oid].url;
  }
  
  // Fallback pour les OID non trouvés
  logger.warn(`OID non trouvé dans les mappings français: ${oid}`);
  return `urn:oid:${oid}`;
}

// Exemple d'utilisation dans la conversion d'un code
function convertHL7CodeToFHIR(hl7Code, oid) {
  const system = resolveOID(oid);
  return {
    system: system,
    code: hl7Code.value,
    display: hl7Code.display || getCodeDisplay(system, hl7Code.value)
  };
}</code></pre>
                    </div>
                </div>
                
                <div class="faq-item">
                    <h3 id="terminology-conflicts">Quelle est la stratégie de gestion des conflits lorsque deux systèmes de terminologie définissent le même code ?</h3>
                    <div class="faq-answer">
                        <p>FHIRHub utilise une stratégie de priorité hiérarchique pour résoudre les conflits entre systèmes de terminologie :</p>
                        
                        <ol>
                            <li><strong>Priorité des systèmes français :</strong> Les codes définis dans les terminologies ANS ont toujours priorité sur les autres.</li>
                            <li><strong>Liste de priorité configurable :</strong> Une liste ordonnée de systèmes permet de définir quel système a préséance en cas de conflit.</li>
                            <li><strong>Journal des conflits :</strong> Tous les conflits détectés sont journalisés pour analyse ultérieure.</li>
                            <li><strong>Mécanisme de qualification :</strong> Le système peut qualifier les codes avec le préfixe du système (ex: "LOINC:12345") pour lever les ambiguïtés.</li>
                        </ol>
                        
                        <p>Implémentation de la résolution de conflits :</p>
                        
                        <pre><code>// Liste ordonnée de priorités des systèmes
const SYSTEM_PRIORITIES = [
  'https://mos.esante.gouv.fr/NOS', // Priorité maximale: NOS français
  'http://loinc.org',               // LOINC
  'http://snomed.info/sct',         // SNOMED CT
  'http://terminology.hl7.org',     // Terminologies HL7
  'http://unitsofmeasure.org',      // UCUM
  // Autres systèmes avec priorité plus basse
];

function resolveCodeConflict(code, systems) {
  if (systems.length === 1) return systems[0]; // Pas de conflit
  
  // Logger le conflit
  logger.warn(`Conflit détecté pour le code '${code}' entre les systèmes: ${systems.join(', ')}`);
  
  // Trier les systèmes selon leur priorité
  systems.sort((a, b) => {
    const priorityA = SYSTEM_PRIORITIES.indexOf(a);
    const priorityB = SYSTEM_PRIORITIES.indexOf(b);
    
    // Si un système n'est pas dans la liste, lui donner la priorité la plus basse
    const aValue = priorityA === -1 ? Number.MAX_SAFE_INTEGER : priorityA;
    const bValue = priorityB === -1 ? Number.MAX_SAFE_INTEGER : priorityB;
    
    return aValue - bValue;
  });
  
  // Retourner le système avec la priorité la plus élevée
  logger.info(`Résolution du conflit en faveur de: ${systems[0]}`);
  return systems[0];
}</code></pre>
                    </div>
                </div>
            </section>

            <!-- Section Conversion HL7 vers FHIR -->
            <section id="conversion" class="faq-section">
                <h2>Conversion HL7 vers FHIR</h2>
                
                <div class="faq-item">
                    <h3 id="conversion-custom">Comment le parseur HL7 identifie-t-il et traite-t-il les segments personnalisés ou non standard ?</h3>
                    <div class="faq-answer">
                        <p>FHIRHub utilise une approche flexible pour traiter les segments personnalisés ou non standard dans les messages HL7 :</p>
                        
                        <ol>
                            <li><strong>Détection automatique :</strong> Le parseur commence par identifier les segments qui ne font pas partie des spécifications standard HL7 v2.5.</li>
                            <li><strong>Registre de segments personnalisés :</strong> Le système maintient un registre configurable de segments personnalisés connus, notamment ceux définis par la spécification française.</li>
                            <li><strong>Mode de préservation :</strong> Les segments non reconnus sont préservés dans une section "extension" des ressources FHIR générées.</li>
                        </ol>
                        
                        <p>Voici comment le parseur traite les segments personnalisés :</p>
                        
                        <pre><code>// Fonction principale de traitement des segments
function processSegment(segment, message) {
  const segmentType = segment.name;
  
  // Vérifier si c'est un segment standard
  if (STANDARD_SEGMENTS.includes(segmentType)) {
    return processStandardSegment(segment, message);
  }
  
  // Vérifier s'il s'agit d'un segment personnalisé connu
  if (CUSTOM_SEGMENT_REGISTRY[segmentType]) {
    logger.info(`Traitement du segment personnalisé: ${segmentType}`);
    return CUSTOM_SEGMENT_REGISTRY[segmentType].handler(segment, message);
  }
  
  // Segment non reconnu - préserver dans les extensions
  logger.warn(`Segment non standard détecté: ${segmentType}. Préservation dans les extensions.`);
  return {
    type: 'Extension',
    url: `http://fhirhub.fr/StructureDefinition/hl7v2-segment-${segmentType.toLowerCase()}`,
    extension: convertSegmentToExtensions(segment)
  };
}</code></pre>

                        <p>Pour les segments personnalisés français spécifiques, le système charge les définitions depuis le fichier <code>french_terminology/ans_hl7_custom_segments.json</code>.</p>
                    </div>
                </div>
                
                <div class="faq-item">
                    <h3 id="conversion-dates">Quelle est la méthode de conversion des dates entre HL7 et FHIR, notamment pour les formats spécifiques français ?</h3>
                    <div class="faq-answer">
                        <p>La conversion des dates est une des opérations les plus délicates, notamment en raison des spécificités françaises. FHIRHub utilise une approche robuste :</p>
                        
                        <ol>
                            <li><strong>Détection de format :</strong> L'application reconnaît automatiquement les différents formats de date HL7 (complets, partiels, avec/sans fuseau horaire).</li>
                            <li><strong>Normalisation :</strong> Toutes les dates sont normalisées en interne vers le format UTC ISO-8601.</li>
                            <li><strong>Gestion des spécificités françaises :</strong> Le système prend en compte les formats français spécifiques (jour/mois/année) et le fuseau horaire Europe/Paris.</li>
                            <li><strong>Préservation de la précision :</strong> Si la date d'origine n'inclut que le jour sans heure, cette précision est respectée dans FHIR.</li>
                        </ol>
                        
                        <p>Voici l'implémentation principale de la conversion de dates :</p>
                        
                        <pre><code>// Convertir une date HL7 en date FHIR
function convertHL7DateToFHIR(hl7Date) {
  if (!hl7Date) return null;
  
  // Détecter le format et la précision
  const format = detectHL7DateFormat(hl7Date);
  
  try {
    // Patterns pour les différents formats de date HL7
    switch (format) {
      case 'YYYYMMDD':
        // Format YYYYMMDD (date uniquement)
        return `${hl7Date.substring(0, 4)}-${hl7Date.substring(4, 6)}-${hl7Date.substring(6, 8)}`;
        
      case 'YYYYMMDDHHMM':
        // Format YYYYMMDDHHMM (date + heure)
        return `${hl7Date.substring(0, 4)}-${hl7Date.substring(4, 6)}-${hl7Date.substring(6, 8)}T` +
               `${hl7Date.substring(8, 10)}:${hl7Date.substring(10, 12)}:00+01:00`;
      
      case 'YYYYMMDDHHMMSS':
        // Format YYYYMMDDHHMMSS (date + heure + secondes)
        return `${hl7Date.substring(0, 4)}-${hl7Date.substring(4, 6)}-${hl7Date.substring(6, 8)}T` +
               `${hl7Date.substring(8, 10)}:${hl7Date.substring(10, 12)}:${hl7Date.substring(12, 14)}+01:00`;
      
      case 'YYYYMMDDHHMMSS.FFFF':
        // Format avec millisecondes
        // Conversion complexe avec gestion des décimales
        // ...
        
      case 'FRENCH_DDMMYYYY':
        // Format spécifique français JJ/MM/AAAA
        return `${hl7Date.substring(4, 8)}-${hl7Date.substring(2, 4)}-${hl7Date.substring(0, 2)}`;
        
      // Autres cas...
        
      default:
        // Tenter une analyse fallback avec les fonctions de date JavaScript
        logger.warn(`Format de date HL7 non reconnu: ${hl7Date}, tentative de parsing standard`);
        const parsedDate = new Date(hl7Date);
        if (!isNaN(parsedDate.getTime())) {
          return parsedDate.toISOString();
        }
        throw new Error(`Format de date non pris en charge: ${hl7Date}`);
    }
  } catch (error) {
    logger.error(`Erreur de conversion de date: ${error.message}`);
    // Préserver la valeur originale si la conversion échoue
    return `${hl7Date} (format non converti)`;
  }
}</code></pre>
                    </div>
                </div>
                
                <div class="faq-item">
                    <h3 id="conversion-errors">Comment le système gère-t-il les erreurs de syntaxe dans les messages HL7 d'entrée ?</h3>
                    <div class="faq-answer">
                        <p>FHIRHub implémente une stratégie de tolérance aux erreurs pour les messages HL7 mal formés :</p>
                        
                        <ol>
                            <li><strong>Validation multi-niveau :</strong> Le message passe par plusieurs niveaux de validation (structure générale, segments, champs).</li>
                            <li><strong>Correction automatique :</strong> Pour certaines erreurs mineures (délimiteurs incorrects, caractères de fin de ligne), le système tente des corrections automatiques.</li>
                            <li><strong>Mode de récupération partielle :</strong> Même en cas d'erreur dans certaines parties du message, le système peut extraire et convertir les segments valides.</li>
                            <li><strong>Rapports d'erreur détaillés :</strong> Toutes les erreurs sont documentées avec leur position exacte et des suggestions de correction.</li>
                        </ol>
                        
                        <p>Voici l'implémentation des principales fonctions de gestion d'erreurs :</p>
                        
                        <pre><code>// Valider et nettoyer un message HL7 d'entrée
function validateAndCleanHL7Message(rawMessage) {
  let cleanedMessage = rawMessage;
  const validationIssues = [];
  
  // 1. Vérification des délimiteurs de base
  if (!cleanedMessage.startsWith('MSH')) {
    validationIssues.push({
      severity: 'error',
      message: 'Le message doit commencer par un segment MSH',
      position: 0
    });
    // Tenter de trouver le début du segment MSH
    const mshIndex = cleanedMessage.indexOf('MSH');
    if (mshIndex > 0) {
      cleanedMessage = cleanedMessage.substring(mshIndex);
      validationIssues.push({
        severity: 'info',
        message: `Caractères initiaux supprimés, début du message ajusté à la position ${mshIndex}`,
        position: 0
      });
    }
  }
  
  // 2. Normalisation des fins de ligne
  cleanedMessage = cleanedMessage.replace(/\\r\\n|\\r|\\n/g, '\\r');
  
  // 3. Vérification des délimiteurs dans le segment MSH
  try {
    const mshSegment = cleanedMessage.split('\\r')[0];
    const fieldSeparator = mshSegment.charAt(3);
    
    if (fieldSeparator === ' ' || !fieldSeparator) {
      validationIssues.push({
        severity: 'error',
        message: 'Séparateur de champ invalide dans le segment MSH',
        position: 3
      });
    }
    
    // Extraire et valider les autres délimiteurs...
  } catch (error) {
    validationIssues.push({
      severity: 'error',
      message: `Impossible d'analyser les délimiteurs: ${error.message}`,
      position: 0
    });
  }
  
  // 4. Vérification de la cohérence des segments
  // ...
  
  // Si des erreurs critiques sont présentes, lever une exception
  const criticalIssues = validationIssues.filter(issue => issue.severity === 'error');
  if (criticalIssues.length > 0) {
    const error = new Error('Le message HL7 contient des erreurs critiques');
    error.validationIssues = validationIssues;
    throw error;
  }
  
  // Retourner le message nettoyé et les avertissements
  return {
    message: cleanedMessage,
    issues: validationIssues
  };
}</code></pre>
                    </div>
                </div>
                
                <div class="faq-item">
                    <h3 id="conversion-datatypes">Comment sont mappés les types de données complexes entre HL7 et FHIR ?</h3>
                    <div class="faq-answer">
                        <p>Le mapping des types de données complexes est géré par un sous-système dédié qui traduit chaque type de données HL7 vers son équivalent FHIR le plus approprié :</p>
                        
                        <ol>
                            <li><strong>Tables de correspondance :</strong> Des tables prédéfinies établissent les correspondances entre types HL7 et FHIR.</li>
                            <li><strong>Convertisseurs spécialisés :</strong> Chaque type complexe (CX, XPN, XAD, etc.) a son propre convertisseur dédié.</li>
                            <li><strong>Préservation des extensions :</strong> Les informations sans équivalent direct sont préservées dans des extensions FHIR.</li>
                        </ol>
                        
                        <p>Exemple d'implémentation pour le type CX (identifiant composite) :</p>
                        
                        <pre><code>// Mapping du type CX (Composite ID) vers un Identifier FHIR
function convertCXtoIdentifier(cxValue) {
  if (!cxValue || !cxValue.id) return null;
  
  const identifier = {
    system: null,
    value: cxValue.id
  };
  
  // Traiter l'autorité d'assignation
  if (cxValue.assigningAuthority) {
    // Vérifier si c'est un OID et le résoudre
    if (cxValue.assigningAuthority.universalId && 
        cxValue.assigningAuthority.universalIdType === 'ISO') {
      identifier.system = resolveOID(cxValue.assigningAuthority.universalId);
    } else if (cxValue.assigningAuthority.namespaceId) {
      // Utiliser le namespace comme fallback
      identifier.system = `urn:oid:${cxValue.assigningAuthority.namespaceId}`;
    }
  }
  
  // Traiter le type d'identifiant
  if (cxValue.identifierTypeCode) {
    const typeCode = cxValue.identifierTypeCode;
    
    // Mapper les codes spécifiques
    if (typeCode === 'INS-C' || typeCode === 'INS-A') {
      // Identifiant national de santé français
      identifier.system = 'https://mos.esante.gouv.fr/NOS/TRE_R304/FHIR/TRE-R304';
      identifier.type = {
        coding: [{
          system: 'https://mos.esante.gouv.fr/NOS/TRE_R304/FHIR/TRE-R304',
          code: typeCode
        }]
      };
    } else {
      // Autres types d'identifiants
      identifier.type = {
        coding: [{
          system: 'http://terminology.hl7.org/CodeSystem/v2-0203',
          code: typeCode
        }]
      };
    }
  }
  
  // Ajouter les dates de validité si présentes
  if (cxValue.effectiveDate) {
    identifier.period = { start: convertHL7DateToFHIR(cxValue.effectiveDate) };
  }
  
  if (cxValue.expirationDate) {
    if (!identifier.period) identifier.period = {};
    identifier.period.end = convertHL7DateToFHIR(cxValue.expirationDate);
  }
  
  return identifier;
}</code></pre>
                    </div>
                </div>
                
                <div class="faq-item">
                    <h3 id="conversion-validation">Quel est le processus de validation des ressources FHIR générées pour s'assurer de leur conformité au standard R4 ?</h3>
                    <div class="faq-answer">
                        <p>FHIRHub implémente un processus de validation en trois phases pour garantir que les ressources FHIR générées sont conformes au standard R4 :</p>
                        
                        <ol>
                            <li><strong>Validation structurelle :</strong> Vérifie que chaque ressource contient tous les éléments obligatoires et respecte les contraintes de cardinalité.</li>
                            <li><strong>Validation sémantique :</strong> S'assure que les valeurs respectent les contraintes de type, de format et de vocabulaire.</li>
                            <li><strong>Validation de profil :</strong> Vérifie la conformité avec les profils français spécifiques définis par l'ANS.</li>
                        </ol>
                        
                        <p>Voici l'implémentation du processus de validation :</p>
                        
                        <pre><code>// Valider une ressource FHIR après conversion
async function validateFHIRResource(resource, profile = null) {
  const validationResults = {
    valid: true,
    issues: []
  };
  
  // 1. Validation structurelle de base
  if (!resource.resourceType) {
    validationResults.valid = false;
    validationResults.issues.push({
      severity: 'error',
      code: 'structure',
      message: 'Ressource sans type défini'
    });
    return validationResults;
  }
  
  // Vérifier les champs obligatoires selon le type de ressource
  const requiredFields = RESOURCE_REQUIRED_FIELDS[resource.resourceType] || [];
  for (const field of requiredFields) {
    if (!resource[field]) {
      validationResults.valid = false;
      validationResults.issues.push({
        severity: 'error',
        code: 'required',
        message: `Champ obligatoire manquant: ${field}`
      });
    }
  }
  
  // 2. Validation sémantique
  // Vérifier les formats de date
  const dateFields = findAllDateFields(resource);
  for (const [path, value] of dateFields) {
    if (!isValidFHIRDate(value)) {
      validationResults.valid = false;
      validationResults.issues.push({
        severity: 'error',
        code: 'value',
        message: `Format de date invalide à ${path}: ${value}`
      });
    }
  }
  
  // Vérifier les références
  const references = findAllReferences(resource);
  for (const [path, ref] of references) {
    if (!ref.reference && !ref.identifier) {
      validationResults.issues.push({
        severity: 'warning',
        code: 'reference',
        message: `Référence sans identifiant à ${path}`
      });
    }
  }
  
  // 3. Validation de profil spécifique (si un profil est spécifié)
  if (profile) {
    try {
      const profileValidation = await validateAgainstProfile(resource, profile);
      if (!profileValidation.valid) {
        validationResults.valid = false;
        validationResults.issues.push(...profileValidation.issues);
      }
    } catch (error) {
      validationResults.issues.push({
        severity: 'warning',
        code: 'processing',
        message: `Erreur lors de la validation du profil: ${error.message}`
      });
    }
  }
  
  return validationResults;
}</code></pre>

                        <p>Pour les validations de profils français, FHIRHub utilise les définitions officielles publiées par l'ANS sur le Modèle des Objets de Santé (MOS).</p>
                    </div>
                </div>
            </section>

            <!-- Ajoutez les autres sections ici... -->
            <section id="ai-integration" class="faq-section">
                <h2>Intégration IA</h2>
                <!-- Ajoutez les FAQ sur l'intégration IA ici -->
            </section>

            <section id="auth-security" class="faq-section">
                <h2>Authentification et sécurité</h2>
                <!-- Ajoutez les FAQ sur l'authentification et sécurité ici -->
            </section>

            <section id="database" class="faq-section">
                <h2>Base de données et persistance</h2>
                <!-- Ajoutez les FAQ sur la base de données ici -->
            </section>

            <section id="workflows" class="faq-section">
                <h2>Workflows et EAI</h2>
                <!-- Ajoutez les FAQ sur les workflows ici -->
            </section>

            <section id="ui" class="faq-section">
                <h2>Interface utilisateur</h2>
                <!-- Ajoutez les FAQ sur l'interface utilisateur ici -->
            </section>

            <section id="architecture" class="faq-section">
                <h2>Architecture système</h2>
                <!-- Ajoutez les FAQ sur l'architecture système ici -->
            </section>

            <section id="api" class="faq-section">
                <h2>API et intégration</h2>
                <!-- Ajoutez les FAQ sur l'API et l'intégration ici -->
            </section>

            <section id="errors-logging" class="faq-section">
                <h2>Gestion des erreurs et logging</h2>
                <!-- Ajoutez les FAQ sur la gestion des erreurs et logging ici -->
            </section>

            <section id="performance" class="faq-section">
                <h2>Performance et optimisation</h2>
                <!-- Ajoutez les FAQ sur la performance et l'optimisation ici -->
            </section>

            <section id="internationalization" class="faq-section">
                <h2>Internationalisation et localisation</h2>
                <!-- Ajoutez les FAQ sur l'internationalisation et la localisation ici -->
            </section>
        </div>
    </div>

    <footer class="footer">
        <div class="container">
            <div class="footer-text">
                &copy; 2025 FHIRHub - Service de conversion HL7 vers FHIR
                <div class="footer-version">Version: <span class="version-text">Chargement...</span></div>
            </div>
            <ul class="footer-links">
                <li><a href="/documentation.html">Documentation</a></li>
                <li><a href="/api-reference.html">API Reference</a></li>
            </ul>
        </div>
    </footer>

    <script src="/js/include-sidebar.js"></script>
    <script src="/js/dev-faq.js"></script>
    <script src="/js/footer-version.js"></script>
</body>
</html>